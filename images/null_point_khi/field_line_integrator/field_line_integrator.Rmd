---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.3.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import sys
import time

import numpy as np
import scipy.interpolate
import sdf
import matplotlib
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.axes_grid1 import make_axes_locatable

sys.path.insert(0,'../')
from sdf_helper_functions import *
from plotting_functions import latexify, save_plot

# %matplotlib widget

INCLUDE_CBARS=True
INCLUDE_TITLE=True
INCLUDE_AXIS_LABELS=True

data_folder = "/nas/1101974q/archie-latest-organisation-sept-2018/null-point-stressing/"
parameter_study_folder = "/twisting-driver/parameter-study/"
```

```{python}
class Integrator:
    def __init__(self, x, y, z, mag_field, integrand_field, h):
        self.h = h
        self.mag_field = mag_field
        self.integrand_field = integrand_field
        self.pos = np.array([x,y,z])
        self.left_integrand = integrand_field.get_value_at(self.pos)
        self.integral = 0.0
        self.length = 0.0
    
    def update(self):
        # Calculate derivative
        derivative = get_derivative(
            self.mag_field, self.pos,self.h)
        
        # Calculate distance between points (i.e. ds)
        ds = np.linalg.norm(derivative)
        
        self.pos += derivative
        
        if self.mag_field.in_field(self.pos):
            right_integrand = self.integrand_field.get_value_at(self.pos)

            # Integrate via mid-point method
            self.integral += ds*0.5*(right_integrand + self.left_integrand)
            self.length += ds

            self.left_integrand  = right_integrand
        else:
            self.running = False
        
    def integrate(self):
        self.running = self.mag_field.in_field(self.pos)
        while self.running:
            self.update()
        
        return self.integral / self.length
```

```{python}
class Line:
    def __init__(self, x, y, z, num_points):
        self.x = np.zeros(num_points+1)
        self.y = np.zeros(num_points+1)
        self.z = np.zeros(num_points+1)
        self.x[0], self.y[0], self.z[0] = x, y, z
        self.current = 0

    def get_pos(self):
        return np.array([
            self.x[self.current],
            self.y[self.current],
            self.z[self.current]])
    
    def add_derivative(self, derivative):
        self.x[self.current+1] = self.x[self.current] + derivative[0]
        self.y[self.current+1] = self.y[self.current] + derivative[1]
        self.z[self.current+1] = self.z[self.current] + derivative[2]        
        self.current += 1
        
    def plot(self, axis, **kwargs):
        axis.plot(line.x[:self.current+1],
                  line.y[:self.current+1],
                  line.z[:self.current+1], **kwargs)
```

```{python}
class VectorField():
    def __init__(self, x, y, z, extents):
        self.x = ScalarField(x, extents)
        self.y = ScalarField(y, extents)     
        self.z = ScalarField(z, extents)
        self.extents = extents
        
    def get_field_at(self, v):
        return np.array([
            self.x.get_value_at(v),
            self.y.get_value_at(v),
            self.z.get_value_at(v)
        ])
    
    def calc_dx_dy_dz(self):
        return self.x.calc_dx_dy_dz()
    
    def in_field(self, pos):
        return self.x.in_field(pos)
```

```{python}
class ScalarField():
    def __init__(self, data, extents):
        self.data = data
        self.extents = extents

        self.x0 = self.extents[:3]
        self.xN = self.extents[3:]
        self.N = data.shape
        
    def calc_dx_dy_dz(self):
        return (self.xN[0] - self.x0[0])/self.N[0],\
            (self.xN[1] - self.x0[1])/self.N[1],\
            (self.xN[2] - self.x0[2])/self.N[2] 

    def length_to_index(self, length, dimension):
        return (length - self.x0[dimension])/(self.xN[dimension]-self.x0[dimension]) * (self.N[dimension]-1)
    
    def get_value_at(self, v):
        x_index = self.length_to_index(v[0], 0)
        y_index = self.length_to_index(v[1], 1)
        z_index = self.length_to_index(v[2], 2)
        i = int(x_index)
        j = int(y_index)
        k = int(z_index)
        x_weight = x_index - i
        y_weight = y_index - j
        z_weight = z_index - k
        
        field_cube = self.data[i:i+2, j:j+2, k:k+2]
        
        z_av = (1.0-z_weight)*field_cube[:,:,0]\
                   + z_weight*field_cube[:,:,1]
        y_av = (1.0-y_weight)*z_av[:,0]\
                   + y_weight*z_av[:,1]
        x_av = (1.0-x_weight)*y_av[0]\
                   + x_weight*y_av[1]

#         x_av = self.data[
#             int(round(x_index)),
#             int(round(y_index)), 
#             int(round(z_index))]
        
        return x_av
    
    def in_field(self, pos):
        i, j, k = int(self.length_to_index(pos[0], 0)),\
                  int(self.length_to_index(pos[1], 1)),\
                  int(self.length_to_index(pos[2], 2))
        in_x = i >= 1 and i < self.N[0]-2
        in_y = j >= 1 and j < self.N[1]-2
        in_z = k >= 1 and k < self.N[2]-2
        return in_x and in_y and in_z
```

```{python}
def get_derivative(field, y, h):
    k1 = h*field.get_field_at(y)
    k2 = h*field.get_field_at(y+0.5*k1)
    k3 = h*field.get_field_at(y+0.5*k2)
    k4 = h*field.get_field_at(y+0.5*k3) 
    return 1.0/6.0 * (k1+2.0*k2+2.0*k3+k4)

def calculate_parallel_electric_field(field):
    bx, by, bz = field.x.data, field.y.data, field.z.data,
    dx, dy, dz = field.calc_dx_dy_dz()

    gradbx = np.gradient(bx, dx, dy, dz)
    gradby = np.gradient(by, dx, dy, dz)
    gradbz = np.gradient(bz, dx, dy, dz)
    
    j_dot_B = (gradbz[1] - gradby[2])*bx - (gradbz[0] - gradbx[2])*by + (gradby[0] - gradbx[1])*bz
    integrand = j_dot_B / (np.sqrt(bx*bx + by*by + bz*bz))

    return integrand

def load_magnetic_field(sdfFilename):
    mag_field = get_magnetic_field(sdfFilename)
    sdfFile = sdf.read(sdfFilename)
    extents = sdfFile.Grid_Grid.extents
    field = VectorField(mag_field[0], mag_field[1], mag_field[2], extents)
    return field
```

```{python}
def example_filename():
    run_folder = "v-4r-4-switching"
    folder = data_folder + parameter_study_folder + run_folder + "/Data/"
    i=10
    timedump = '{0:04d}'.format(i)
    sdfFilename = folder + timedump + ".sdf"
    
    return sdfFilename
```

```{python}
sdfFilename = example_filename()

field = load_magnetic_field(sdfFilename)

NUM_POINTS = int(1e4)

N_ANGLES = 10
RADIUS = 0.05

# field = Field(sdfFilename)
lines = [Line(RADIUS*np.cos(theta), RADIUS*np.sin(theta), 0.23, NUM_POINTS) for theta in np.linspace(0, 2.0*np.pi, N_ANGLES)]
lines += [Line(RADIUS*np.cos(theta), RADIUS*np.sin(theta), -0.23, NUM_POINTS) for theta in np.linspace(0, 2.0*np.pi, N_ANGLES)]

h = 1e-2

for line in lines:
    pos = line.get_pos()
    while field.in_field(pos) and line.current<NUM_POINTS:
        derivative = get_derivative(field, pos, h)
        line.add_derivative(derivative)
        pos = line.get_pos()
```

```{python}
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
for i, line in enumerate(lines[::-1]):
#     if i<N_ANGLES:
#         color = "red"
#     else:
#         color = "blue"
    cmap = matplotlib.cm.get_cmap('viridis')
    rgba = cmap(0.0)
    line.plot(ax, color=rgba, linewidth=0.5)
plt.show()
```

```{python}
def plot_integration(data,
               cbar=INCLUDE_CBARS,
               include_title=INCLUDE_TITLE,
               include_axis_labels=INCLUDE_AXIS_LABELS,
               xlim=False, ylim=False, title=False, interpolation='none'):
    
    latexify(columns=1)
    fig, axis = plt.subplots()

    im = axis.imshow(data.T,\
                interpolation=interpolation,\
                cmap=plt.get_cmap("viridis"),
               extent=extents, origin='lower')

    if xlim:
        axis.set_xlim(xlim)
    if ylim:
        axis.set_ylim(ylim)
        
    if include_title:
        if title:
            axis.title.set_text(" ".join(title.split("_")))

    if include_axis_labels:
        axis.set_xlabel("x")
        axis.set_ylabel("y")
        
    if cbar:
        divider = make_axes_locatable(axis)
        cax = divider.append_axes("right", size="5%", pad=0.05)
        plt.colorbar(im, cax=cax)
```

```{python}
run_folder = "v-4r-4-switching"
folder = data_folder + parameter_study_folder + run_folder + "/Data/"
i=10
timedump = '{0:04d}'.format(i)
sdfFilename = folder + timedump + ".sdf"

mag_field = load_magnetic_field(sdfFilename)

pef_data = calculate_parallel_electric_field(mag_field)
pef_field = ScalarField(pef_data, mag_field.extents)

h = 1e-2

n_values = 50
square_sides = 0.5
z_level = 0.23
extents = [-square_sides, square_sides,
           -square_sides, square_sides]



for h in [1e-2, 5e-3, 1e-3]:
    for n_values in [10, 25, 50]:
        seeds = xy = np.mgrid[
            extents[0]:extents[1]:(n_values)*1j,
            extents[2]:extents[3]:(n_values)*1j, 
            z_level:z_level:1j].reshape(3,-1).T
        integrators = [Integrator(seed[0], seed[1], seed[2], mag_field, pef_field, h) for seed in seeds]
        start = time.time()
        result = np.array([
            integrator.integrate() for integrator in integrators
        ]).reshape(n_values, n_values)
        end = time.time()
        print(h, n_values, end - start)

# plot_integration(result,
#                  title=run_folder + "_" + timedump + "_z_" + str(z_level))
# plt.show()
```

```{python}

```
